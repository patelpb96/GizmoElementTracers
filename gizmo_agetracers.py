'''

Post-process metal abundances using the stellar age tracers passive scalars in
the FIRE-3 set of simulations.

@author: Andrew Emerick <aemerick11@gmail.com>

In addition to metallicity fields tracked natively in FIRE-3 (see gizmo_star.py),
the FIRE-3 simulations follow metal enrichment using stellar age bins. Stars
at a given age deposit into their corresponding age bin. MORE

This post-processing requires one to compute the weightings for each age-bin for
each element. This consists of a table which contains the total amount of mass
of each element produced during each time bin. This can be constructed here
using some default enrichment models, but can also be user-generated entirelly
externally to this routine, or can be generated here if provided with an object
that accepts an element name and time as parameters and returns the instantaneous
mass loss rate of that element at that time.


Units: unless otherwise noted, all quantities are in (combinations of):
    mass [M_sun]
    position [kpc comoving]
    distance, radius [kpc physical]
    velocity [km / s]
    time [Gyr]
'''

import numpy as np
from scipy import integrate

from . import gizmo_star
# import utilities as ut


def construct_yield_table(yield_object, agebins,
                          elements = None, integration_points = None):
    """
    Construct a table of weights to post-process the age tracer fields
    with individual elemental abundances. Given a function which accepts
    elements and time as arguements, builds this table by summing up the total
    yield for each element during each time bin.

    Parameters
    -----------

    yield_object : obj
        An object with a required method "yield" that is a function of
        where the first is a time in Gyr and the second is a full element
        name in all lowercase (e.g. 'oxygen','carbon'). This
        function must return the instantaneous, specific mass loss rate for that element
        in units of (Msun / Gyr) per solar mass of star formation.

        This object must also have an attribute 'elements' which is the list
        of all elements able to be generated by this yield model. If making
        your own object to generate a yields table,
        for convenience, one can use the 'generate_element_list' function
        which returns element names between a range of atomic numbers. If total
        metallicity is to be computed, 'metals' must be one of these elements.

        If yield_object contains the attribute 'integration_points', these
        will be passed to the integrator (scipy.integrate.quad). Otherwise these
        can be provided as a separate argument.


    elements : list, optional
        List of elements to generate for the table. If None, all possible
        elements in yield_object.elements will be used

    integration_points : (sequence of floats, ints), optional
        Points to be passed to scipy.integrate.quad to be careful around. This
        can also be passed if 'integration_points' is an attribute of
        the yields_object. This argument overrides the yield_object
        attribute if provided. Default : None

    """

    for e in elements:
        assert e in yield_object.elements

    yield_table = np.zeros(  (np.size(agebins)-1, np.size(elements)))


    # grab points to be carful around for integration (if available)
    points = None
    if not (integration_points is None):
        points = integration_points
    else:
        if hasattr(yield_object, 'integration_points'):
            if len(yield_object.integration_points) > 0:
                points = yield_object.integration_points

    # generate yield weights for each age bin
    for i in np.arange(np.size(agebins)-1):

        if i == 0: # ensure min time starts at 0
            min_t = 0.0
        else:
            min_t = agebins[i]

        max_t = agebins[i+1]

        for j,e in enumerate(elements):
            yield_table[i][j] = integrate.quad( yield_object.yields,
                                min_t, max_t,
                                args = (e,), points = points)[0]
    return yield_table


class YieldsObject ():

    def __init__(self, name = ''):
        self.name = name

        self.elements = []


        return

    def yields(self, t, element):
        pass


# ------------------------------------------------------------------------------
# FIRE2 Yield Class object for generating yield tables for age-tracer
# post-processing. This serves as an example
# ------------------------------------------------------------------------------

class FIRE2_yields(YieldsObject):
    '''
    Object desigend for use with the construct_yield_table method. This object
    Provides the yields for the default FIRE2 chemical evolution model. This
    model uses some metallicity depended yields, determined by two paramters.
    '''
    def __init__(self, name = "FIRE2", model_Z = 1.0, Z_scaling=True):
        """
        Initialize object and pre-load some things for convenience.

        Parameters
        -----------
        name  : str, optional
            Optional name for this table. Default : FIRE2
        model_Z : float, Optional
            Metallicity (in solar units) for metallicity dependent yield
            scalings in the FIRE2 model. Default: 1.0 (solar)
        Z_scaling : bool, optional
            Apply the FIRE2 metallicity scalings in approximate fashion.
            Default : True
        """

        super().__init__(name)

        # Not required. Specific parameters for this model
        self.model_parameters = {'model_Z' : model_Z,
                                 'Z_scaling' : Z_scaling}

        # Not required, but useful
        self.elements = ['metals','helium','carbon','nitrogen','oxygen',
                         'neon','magnesium','silicon','sulphur',
                         'calcium','iron']


        # Not required
        # to use for metallicity dependent corrections on the yields
        # this just assumes that all yields come from stars with metallicities
        # and individual abundances scaled to the solar abundance pattern
        # this isn't accurate in practice but gives better agreement between
        # post-processed yields and native simulated yields in the FIRE-2 model.
        star_massfraction = {}
        for e in self.elements:
            star_massfraction[e]    = self.model_parameters['model_Z'] *\
                                      gizmo_star.sun_massfraction[e]

        # pre-load yields since they are constants in time.
        # in general, this probably cannot be done if they are time-varying
        # and would have to make separete function calls or something in
        # the yields method

        #  Yields here is a dictionary with element names as kwargs
        # and yields (in Msun) as values
        self.snIa_yields = gizmo_star.get_nucleosynthetic_yields('supernova.ia',
                                                  star_metallicity=self.model_parameters['model_Z'],
                                                  star_massfraction=star_massfraction,
                                                  normalize=False)

        self.snII_yields = gizmo_star.get_nucleosynthetic_yields('supernova.ii',
                                              star_metallicity=self.model_parameters['model_Z'],
                                              star_massfraction=star_massfraction,
                                              normalize=False)
        #    wind yields do not have quantized rates. These are mass fraction
        #
        self.wind_yields = gizmo_star.get_nucleosynthetic_yields('wind',
                                              star_metallicity=self.model_parameters['model_Z'],
                                              star_massfraction=star_massfraction,
                                              normalize=False)


        #
        # Points (in Gyr) to be careful around during integration. These are
        # all
        self.integration_points =  np.sort([0.003401, 0.010370, 0.03753,
                                            0.001, 0.05, 0.10, 1.0, 14.0])


        return

    def yields(self, t, element):
        """

        Returns the total yields for all FIRE processes. This method is REQUIRED
        by construct_yield_table.

        Parameters
        -----------
        t    : float or np.ndarray
            Time (in Gyr) to compute instantaneous yield
        element : str : Must be in self.elements
            Element name

        Returns
        -----------
        y : float or np.ndarray
            Total yields at a given time for desired element in units of
            Msun / Gyr per Msun of star formation.
        """

        assert element in self.elements

        # get SNIa rate at a given time (in units of 1/Myr per Msun of SF)
        snIarate = gizmo_star.SupernovaIa.get_rate(t*1000.0, 'mannucci')

        # get snII rate at given time (in units of 1/Myr per Msun of SF)
        snIIrate = gizmo_star.SupernovaII.get_rate(t*1000.0)

        # get widnd rate at given time (in units of Msun/Myr per Msun of SF)
        #   this is the only model in the FIRE default that is Z dependent
        windrate = gizmo_star.StellarWind.get_rate(t*1000.0, metallicity=self.model_parameters['model_Z'])

        y =  ( (self.wind_yields[element] * windrate) +\
               (self.snIa_yields[element] * snIarate) +\
               (self.snII_yields[element] * snIIrate))  # in Msun / Myr

        return y * 1000.0 # Msun / Gyr






# ------------------------------------------------------------------------------
#
# Helper things 
#
# ------------------------------------------------------------------------------

# a list of all elements up to uranmium
ElementList = ['hydrogen','helium','lithium','beryllium','boron','carbon','nitrogen',
               'oxygen','flourine','neon','sodium','magnesium','alumnimum','silicon',
               'phosphorus','sulfur','chlorine','argon','potassium','calcium','scandium',
               'titatium','vanadium','chromium','manganese','iron','cobalt','nickel','copper',
               'zinc','gallium','germanium','arsenic','selenium','bromine','krypton','rubidium',
               'strontium','yttrium','zirconium','niobium','molybdenum','technetium','ruthenium',
               'rhodium','palladium','silver','cadmium','indium','tin','antimony','tellurium',
               'iodine','xenon','cesium','barium','lanthanum','cerium','praseodymium',
               'neodymium','promethium','samarium','europium','gadolinium','terbium',
               'dysprosium','holmium','erbium','thulium','ytterbium','lutetium',
               'hafnium','tantalum','tungsten','rhenium','osmium','iridium','platinum',
               'gold','mercury','thallium','lead','bismuth','polonium','astatine','radon',
               'francium','radium','actinium','thorium','protactinium','uranium']

StableElementList = list(np.array(ElementList)[:83]).remove("technetium")

ElementSymbols = ['h','he','li','be','b','c','n',
                  'o','f','ne','na','mg','al','si',
                  'p','s','cl','ar','k','ca','sc',
                   'ti','v','cr','mn','fe','co', 'ni','cu',
                  'zn','ga','ge','as','se','br','kr','rb',
                  'sr','y','zr','nb','mo','tc','ru',
                  'rh','pd','ag','cd','in','sn','sb','te',
                  'i','xe','cs','ba','la','ce','pr',
                  'nd','pm','sm','eu','gd','tb',
                  'dy','ho','er','tm','yb','lu',
                  'hf','ta','w','re','os','ir','pt',
                  'au','hg','tl','pb','bi','po','at','rn',
                  'fr','ra','ac','th','pa','u']

ElementSymbolMapper = {}
for i,k in enumerate(ElementSymbols):
    ElementSymbolMapper[k] = ElementList[i]
for i,k in enumerate(ElementList):
    ElementSymbolMapper[k] = ElementSymbols[i]
